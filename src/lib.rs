pub trait RandomNumberGeneratorEngine{
    type ResultType;
    type StateType;

    /// set the current state of engine
    /// if input seed is None,then use the default seed
    /// default seed should provided by implement
    fn set_seed(&mut self ,seed:Option<Self::StateType>);
    /// get the state of current engine
    fn get_state(&self)->Self::StateType;
    /// advance the engine`s state by n steps
    fn discard(&mut self,n:usize);
    /// get a possible smallest number of this engine
    const MIN:Self::ResultType;
    /// get a possible largest number of this engine
    const MAX:Self::ResultType;
    /// get a random number generated by engine and update state
    fn get(&mut self)->Self::ResultType;
    /// get a random number smaller than round
    /// round should be a number bigger than 0
    fn get_round(&mut self,round:Self::ResultType)->Self::ResultType;
}
pub struct PcgWithXorshift{
    state:<Self as RandomNumberGeneratorEngine>::StateType,
    //self Multiplier
    //multi:<Self as RandomNumberGeneratorEngine>::StateType,
}
impl PcgWithXorshift {

    //default multiplier and default seed
    //0x853c49e6748fea9bULL, 0xda3e39cb94b95bdbULL
    //from the minimal implementation of the pcg32_fast PRNG from <https://www.pcg-random.org>.
    const DEFAULT_MULTIPLIER:<PcgWithXorshift as RandomNumberGeneratorEngine>::StateType = 0x853c49e6748fea9bu64;
    const DEFAULT_SEED:<PcgWithXorshift as RandomNumberGeneratorEngine>::StateType = 0xda3e39cb94b95bdbu64;
    const DEFAULT_ADDER:<PcgWithXorshift as RandomNumberGeneratorEngine>::StateType = 0x6364136223846793u64;

    /// Constructs the engine with a default or optionally given seed.
    pub fn new(seed:Option<<Self as RandomNumberGeneratorEngine>::StateType>)->PcgWithXorshift{
        PcgWithXorshift { state: Self::checked_seed(seed) }
    }
    /// provide legal seed
    pub fn checked_seed(seed:Option<<Self as RandomNumberGeneratorEngine>::StateType>)-><PcgWithXorshift as RandomNumberGeneratorEngine>::StateType{
        seed.unwrap_or(Self::DEFAULT_SEED.wrapping_add(Self::DEFAULT_ADDER) << 1 | 1u64)
    }
    
    /// update the state
    pub fn update(&mut self){
        self.state = self.state.wrapping_mul(Self::DEFAULT_MULTIPLIER).wrapping_add(Self::DEFAULT_ADDER);
    }

    /// 64-bits xorshift algorithm use state to generate result
    const fn generate(mut state:<Self as RandomNumberGeneratorEngine>::StateType)-><PcgWithXorshift as RandomNumberGeneratorEngine>::ResultType{
        type ResultType = <PcgWithXorshift as RandomNumberGeneratorEngine>::ResultType;
        state ^= state << 13;
        state ^= state >> 7;
        state ^= state << 17;
        state as ResultType
    }
}
impl RandomNumberGeneratorEngine for PcgWithXorshift {
    type ResultType = u32;
    type StateType = u64;

    const MIN:Self::ResultType = u32::MIN;
    const MAX:Self::ResultType = u32::MAX;
    fn set_seed(&mut self ,seed:Option<Self::StateType>) {
        self.state = Self::checked_seed(seed)
    }
    fn discard(&mut self,n:usize) {
        for _ in 0..n{
            self.update();
        }
    }
    fn get(&mut self)->Self::ResultType {
        let old_state = self.get_state();
        self.update();
        Self::generate(old_state)
    }
    fn get_round(&mut self,round:Self::ResultType)->Self::ResultType {
        let threshold = (Self::ResultType::MAX - round) % round;
        loop{
            let r = self.get();
            if r >= threshold{
                return  r % round;
            }
        }
    }
    fn get_state(&self)->Self::StateType {
        self.state
    }
}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn set_seed_test(){
        let mut pcg = PcgWithXorshift::new(None);
        assert_eq!(pcg.get_state(),0xda3e39cb94b95bdbu64.wrapping_add(0x6364136223846793u64)<<1 | 1u64);
        pcg.set_seed(Some(1223151351));
        assert_eq!(pcg.get_state(),1223151351);
    }
    #[test]
    fn discart_test(){
        let mut pcg1 = PcgWithXorshift::new(None);
        let mut pcg2 = PcgWithXorshift::new(None);
        pcg1.update();
        pcg1.update();
        pcg1.update();
        pcg2.discard(3);
        assert_eq!(pcg1.get(),pcg2.get());
    }

}
